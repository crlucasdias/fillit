Notas:

Alterar nome das funcoes e variaveis, alem de dividir por file.

Decidir como os dados vao ser passados, por array com ft_atoi no solver ou oq


Fazer algumas validacoes apos criacao y tals

Exemplo de validacao: Limpar lista caso de ruim


------



//chama funcao pra criar
//se nao existir tetrimino[count_line][0] = malloc
//else realloc

//Passo a passo:
/*
    1 - Quantidade de linhas para fazer o malloc no array multidimensional.
    2 - Pegar character e keep tracking
*/
//  tmp_arr[0] = malloc(sizeof(char) * 2);
  //  tmp_arr[0][0] = 'a';
  //  printf("Valor: %c", tmp_arr[0][0]);
    //tmp_arr[count_lines][0] = 'a';
   // lst->tetrimino[characters] = malloc(sizeof(int));
   // lst->tetrimino[count_lines][characters] = 1;

/*

-1 esquerda.
+1 direita.


*/
    /* 
    
    Como vou resolver?

    Melhor solucao: Keep tracking.
    como isso funciona?

    1 -> Pra direita
    0 -> Mesma posicao
    -1 -> Pra esquerda

    ...#
    ...#
    ...#
    ...#

    linha[0][0] = 1
    linha[1][0] = 1
    linha[2][0] = 1
    linha[3][0] = 1

    ....
    ....
    ....
    ####

    linha[0][0] = 1
    linha[0][1] = 1
    linha[0][2] = 1
    linha[0][3] = 1

    .###
    ...#
    ....
    ....

    linha[0][0] = 1
    linha[0][1] = 1
    linha[0][2] = 1
    linha[1][0] = 0

    ....
    ..##
    .##.
    ....

    linha[0][0] = 1
    linha[0][1] = 1a
    linha[1][0] = -2
    linha[1][1] = 1

    ##
    #
    #

    
    
        formas de resolver. 
        Opcao 1:
        Keep track da ultima posicao com numero.
        linha[x][3]
        linha[x][4]

        linha[0][0] = 2
        linha[0][1] = 3
        linha[1][0] = 4
        linha[2][0] = 4


        xx##
        xxx#
        xxx#

        Nao adianta. Por uma razao simples, ele nao necessariamente vai ficar
        nessas posicoes

        Opcao 2:
        Faz a copia inteira com os .
        no final tenta encaixar so aonde tem posicao
        ...x
        ...x
        ...x
        ..x.

    */



/*
typedef struct l_tetriminos 
{
    char character;
    int tetrimino[4];
    struct l_tetriminos *next;
} l_tetriminos;


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

l_tetriminos *list_add(l_tetriminos *lst, char character)
{
    lst = malloc(sizeof(l_tetriminos));
    if(!lst)
        return (0);
    lst->character = character;
    lst->next = '\0';
    return (lst);
}


void create_tetrimino(l_tetriminos **lst, char character)
{
    l_tetriminos *tmp;

    tmp = *lst;
    while(tmp)
    {
      tmp = tmp->next;
    }
    tmp = list_add(tmp,character);
}


int main() {

  l_tetriminos *lista;
  char character = 'a';
  lista = list_add(lista, character);
  character++;
  while(character < 'e')
  {
      create_tetrimino(&lista,character);
      character++;
  }
  return 0;
}

int get_tetrimino(l_tetriminos *lst, char *data)
{
    int lineSize;
    int i;
    int base;

    lineSize = 0;
    base = 0;
    i = 0;

    printf("Data: %s \n",data);
    while(data[i])
    {
        if(data[i] == TETRIMINO_CHARACTER)
        {
            lst->tetrimino[base] = base;
            //printf( "%d\n", lst->tetrimino[base]);
            base++;
        }
        i++;
    }
    return (1);

*/

---------------------


Organizando codigo:

is_valid_file();
if (is_valid_file = return read

dai, treta com tetriminos e faz oq tem de ser feito.


Como o codigo rola:


1 - Verify file

if - ok -> Return data. (fd)

2 - Create tetriminos (cria uma lista de tetriminos)

2.1 -> create_tetriminos
2.2 -> tetrimino_to_list
2.3 -> list_add
2.4 -> create_tetrimino (will add correct tetrimino to list)
2.5 -> build_tetrimino_array();




/* cria a lista e percorre. */

    /* printa lista .. debug 
   /// printf("COmecnado: \n");
    while(list_tetriminos)
    {
    //    print_array(list_tetriminos->tetrimino);
        //printf("Character: %c \n", list_tetriminos->character);
        list_tetriminos = list_tetriminos->next;
      //  printf("Next.. \n");
    }
    */


    O que eh backtracking:

    sempre q vc tem um programa q precisa de diversas solucoes
    se vc tentar uma solucao e der merda, volta pra tentar uma nova.



Notas:

Before backtracking:

-> is_square.. verifico se eh um quadrado ou nao
-> grow map.. -> cpy current map and grow them.



solver



   // print_array(list_tetriminos->tetrimino);
   // return (0);
   /* printf("%d \n", list_tetriminos->tetrimino[row][0]);
    printf("%d \n", list_tetriminos->tetrimino[row][1]);
    printf("%d \n", list_tetriminos->tetrimino[row + 1][0]);
    printf("%d \n", list_tetriminos->tetrimino[row + 2][0]);
    printf("END \n \n \n");
    printf("J Inicial : %d \n \n", j + '0');
*/

            /* else if (list_tetriminos->tetrimino[row + 1] && ((j + '0') < list_tetriminos->tetrimino[row + 1][0]))
            {
                  printf("entrou aqi");
                  j = j - 1;
            } */


// else if (list_tetriminos->tetrimino[row + 1] && ((j + '0') < list_tetriminos->tetrimino[row + 1][0]))
            //    j = j - 1;


//problemas:
/*
como tratar com a lista nesse caso?
quando eh o fim?
*/

/*
    Como resolver o problema? 

    Parte 1:

    1. Pego o head e o mapa vazio.
    2. Percorro o mapa, procurando a primeira posicao vazia.
    3. Se encontrar, comeco a insercao no mapa com a list_tetriminos->character.

    Parte 2:
    
      Recebo o mapa.

 printf("list_tetriminos->tetrimino[row][column] ANTES: %d \n", list_tetriminos->tetrimino[row][column]);
            printf("J antes: %d \n", j);
            if (list_tetriminos->tetrimino[row][column + 1])
            {
                printf("list_tetriminos->tetrimino[row][column] DEPOIS %d \n", list_tetriminos->tetrimino[row][column + 1]);
                j = j + (list_tetriminos->tetrimino[row][column + 1] - list_tetriminos->tetrimino[row][column]);
            }
            printf("J depois: %d \n", j);
            printf("Next \n \n");


//if(list_tetriminos->tetrimino[0][0] && ! list_tetriminos->tetrimino[0][1])
      //  j = list_tetriminos->tetrimino[0][0] - j - '0';
    printf("J inicial: %d \n", j);
    printf("%d \n", list_tetriminos->tetrimino[row][0]);
    printf("%d \n", list_tetriminos->tetrimino[row + 1][0]);
    printf("%d \n", list_tetriminos->tetrimino[row + 1][1]);
    printf("%d \n", list_tetriminos->tetrimino[row + 1][2]);
    printf("END \n \n \n");
int  try_fillit(char **map, l_tetriminos *list_tetriminos, int i, int j)
{
    int row;
    int column;
    int aux;

    row = 0;
    column = 0;

    printf("%d \n", list_tetriminos->tetrimino[row][0]);
    printf("%d \n", list_tetriminos->tetrimino[row][1]);
    printf("%d \n", list_tetriminos->tetrimino[row + 1][0]);
    printf("END \n \n \n");
    printf("J Inicial : %d \n \n", j + '0');

    //Divergencia dos J indiferente, pq um eh do map e o outro do fillit.

    while(list_tetriminos->tetrimino[row])
    {
        while(list_tetriminos->tetrimino[row][column])
        {
            if(map[i][j] != EMPTY_CHARACTER)
                return(0);
            map[i][j] = list_tetriminos->character; //vai dar seg fault quando o map[j] == null
            if (list_tetriminos->tetrimino[row][column + 1])
            {
                  printf("J Dentro IF:  %d \n", j + '0');
                  j = j + (list_tetriminos->tetrimino[row][column + 1] - list_tetriminos->tetrimino[row][column]);
            }
            else if(list_tetriminos->tetrimino[row + 1] && list_tetriminos->tetrimino[row + 1][column - 1])
            {
                printf("J Else if Fora: %d \n", j + '0');
                j = j - 1;
            }
            else
            {
                //printf("tmp[%d][%d]\n", i, j);
                printf("J Fora: %d \n", j + '0');
                //printf("Tetrimino: %d \n", list_tetriminos->tetrimino[row + 1][0]);
                //printf("\n\n");
            }
            column++;
        }
        i += 1;
        row++;
        column = 0;
    }
    print_map(map);
    return (1);
}



Problema:

.#..
###.

O # inicia no J, mas nesse caso, eh pra ele iniciar no j + 1
*/