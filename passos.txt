Notas:

Alterar nome das funcoes e variaveis, alem de dividir por file.

Decidir como os dados vao ser passados, por array com ft_atoi no solver ou oq


Fazer algumas validacoes apos criacao y tals

Exemplo de validacao: Limpar lista caso de ruim


------



//chama funcao pra criar
//se nao existir tetrimino[count_line][0] = malloc
//else realloc

//Passo a passo:
/*
    1 - Quantidade de linhas para fazer o malloc no array multidimensional.
    2 - Pegar character e keep tracking
*/
//  tmp_arr[0] = malloc(sizeof(char) * 2);
  //  tmp_arr[0][0] = 'a';
  //  printf("Valor: %c", tmp_arr[0][0]);
    //tmp_arr[count_lines][0] = 'a';
   // lst->tetrimino[characters] = malloc(sizeof(int));
   // lst->tetrimino[count_lines][characters] = 1;

/*

-1 esquerda.
+1 direita.


*/
    /* 
    
    Como vou resolver?

    Melhor solucao: Keep tracking.
    como isso funciona?

    1 -> Pra direita
    0 -> Mesma posicao
    -1 -> Pra esquerda

    ...#
    ...#
    ...#
    ...#

    linha[0][0] = 1
    linha[1][0] = 1
    linha[2][0] = 1
    linha[3][0] = 1

    ....
    ....
    ....
    ####

    linha[0][0] = 1
    linha[0][1] = 1
    linha[0][2] = 1
    linha[0][3] = 1

    .###
    ...#
    ....
    ....

    linha[0][0] = 1
    linha[0][1] = 1
    linha[0][2] = 1
    linha[1][0] = 0

    ....
    ..##
    .##.
    ....

    linha[0][0] = 1
    linha[0][1] = 1
    linha[1][0] = -2
    linha[1][1] = 1

    ##
    #
    #

    
    
        formas de resolver. 
        Opcao 1:
        Keep track da ultima posicao com numero.
        linha[x][3]
        linha[x][4]

        linha[0][0] = 2
        linha[0][1] = 3
        linha[1][0] = 4
        linha[2][0] = 4


        xx##
        xxx#
        xxx#

        Nao adianta. Por uma razao simples, ele nao necessariamente vai ficar
        nessas posicoes

        Opcao 2:
        Faz a copia inteira com os .
        no final tenta encaixar so aonde tem posicao
        ...x
        ...x
        ...x
        ..x.

    */



/*
typedef struct l_tetriminos 
{
    char character;
    int tetrimino[4];
    struct l_tetriminos *next;
} l_tetriminos;


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

l_tetriminos *list_add(l_tetriminos *lst, char character)
{
    lst = malloc(sizeof(l_tetriminos));
    if(!lst)
        return (0);
    lst->character = character;
    lst->next = '\0';
    return (lst);
}


void create_tetrimino(l_tetriminos **lst, char character)
{
    l_tetriminos *tmp;

    tmp = *lst;
    while(tmp)
    {
      tmp = tmp->next;
    }
    tmp = list_add(tmp,character);
}


int main() {

  l_tetriminos *lista;
  char character = 'a';
  lista = list_add(lista, character);
  character++;
  while(character < 'e')
  {
      create_tetrimino(&lista,character);
      character++;
  }
  return 0;
}

int get_tetrimino(l_tetriminos *lst, char *data)
{
    int lineSize;
    int i;
    int base;

    lineSize = 0;
    base = 0;
    i = 0;

    printf("Data: %s \n",data);
    while(data[i])
    {
        if(data[i] == TETRIMINO_CHARACTER)
        {
            lst->tetrimino[base] = base;
            //printf( "%d\n", lst->tetrimino[base]);
            base++;
        }
        i++;
    }
    return (1);

*/

---------------------


Organizando codigo:

is_valid_file();
if (is_valid_file = return read

dai, treta com tetriminos e faz oq tem de ser feito.


Como o codigo rola:


1 - Verify file

if - ok -> Return data. (fd)

2 - Create tetriminos (cria uma lista de tetriminos)

2.1 -> create_tetriminos
2.2 -> tetrimino_to_list
2.3 -> list_add
2.4 -> create_tetrimino (will add correct tetrimino to list)
2.5 -> build_tetrimino_array();




/* cria a lista e percorre. */

    /* printa lista .. debug 
   /// printf("COmecnado: \n");
    while(list_tetriminos)
    {
    //    print_array(list_tetriminos->tetrimino);
        //printf("Character: %c \n", list_tetriminos->character);
        list_tetriminos = list_tetriminos->next;
      //  printf("Next.. \n");
    }
    */


    O que eh backtracking:

    sempre q vc tem um programa q precisa de diversas solucoes
    se vc tentar uma solucao e der merda, volta pra tentar uma nova.